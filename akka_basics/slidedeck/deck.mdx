import { condensed } from 'mdx-deck/themes'
import { CodeSurfer } from 'mdx-deck-code-surfer';
import darcula from "prism-react-renderer/themes/vsDarkPlus"
import { code } from './codeSamples/example.js';
import { chart } from './charts/testchart.js';
import { Notes, Appear, Head } from 'mdx-deck';
import { Invert, Split, SplitRight, FullScreenCode } from 'mdx-deck/layouts';
import Mermaid from './components/mermaid.js';

[//]: # (GLOBAL THEME SETUP)

export const theme = {
    ...condensed,
    codeSurfer: {
        ...darcula,
        showNumbers: true,
        dark: true
    }
}



[//]: # (SLIDES)

export default Invert

# Akka.Net Basics

[github.com/spyfu/brownbags](https://github.com/spyfu/brownbags) to follow along

<Notes>
<h1>Can I use html here?</h1>
</Notes>

<Head>
    <title>Akka.Net Basics</title>
</Head>

---

export default Split

<div>

# What we're going to cover
* Actor Model
* Akka.Net
* Routing and Worker Pools

</div>

<div>

# Things we won't cover
* Akka.Net Persistance
* Akka.Net Remote / Clustering
* Akka.Net Testing

</div>

<Notes>Only in presenter mode</Notes>

---

export default Invert

# The Actor Model

<Appear>
    <p> Actors are the primary unit doing work in the actor model. </p>
    <p> Actors communicate by passing messages. </p>
    <p> Each actor will only process one message at a time. Messages are (generally) processed in the order they are received (not necessarily the order they were sent.) </p>
    <p> Actors can be on the same machine, or spread accross many machines. </p>
    <p> The actor model makes both concurrency and distributed workloads easier. </p>
</Appear>

---

# Akka.Net

<Appear>
    <p></p>
</Appear>

---

export default Invert

# Mermaid slide

<Mermaid 
    chart={chart}
/>

---

<CodeSurfer 
    code={code} 
    title='egads' 
    notes= 'wat'
    steps={[
        { range: [2, 7], notes: "we'll start with an example from petabridge" },
    ]}
/>